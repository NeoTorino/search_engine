# Enhanced services/utils.py with comprehensive security

import re
import html
import logging
import time
from datetime import datetime, timedelta
from urllib.parse import quote
from typing import List, Tuple, Optional, Dict, Any
import unicodedata

# Configure security logging
security_logger = logging.getLogger('security')
security_logger.setLevel(logging.WARNING)

# Add file handler if not exists
if not security_logger.handlers:
    handler = logging.FileHandler('security.log')
    formatter = logging.Formatter('%(asctime)s %(levelname)s [%(name)s] %(message)s')
    handler.setFormatter(formatter)
    security_logger.addHandler(handler)

# Rate limiting storage (in production, use Redis)
_rate_limit_storage = {}

def sanitize_input(input_str: str, max_length: int = 200, allow_basic_html: bool = False) -> str:
    """
    Comprehensive input sanitization with multiple layers of protection
    """
    if not input_str or not isinstance(input_str, str):
        return ""
    
    # Remove null bytes and dangerous control characters
    input_str = input_str.replace('\x00', '')
    input_str = ''.join(char for char in input_str if ord(char) >= 32 or char in '\t\n\r')
    
    # Normalize unicode to prevent bypass attempts
    try:
        input_str = unicodedata.normalize('NFKC', input_str)
    except Exception:
        # If normalization fails, strip non-ASCII
        input_str = ''.join(char for char in input_str if ord(char) < 128)
    
    # Length limiting (prevent DoS)
    input_str = input_str[:max_length]
    
    if allow_basic_html:
        # Use basic HTML sanitization for display purposes
        allowed_tags = ['b', 'i', 'em', 'strong']
        # Remove all tags except allowed ones
        input_str = re.sub(r'<(?!/?(?:' + '|'.join(allowed_tags) + r')\b)[^>]*>', '', input_str)
    else:
        # Remove all HTML/XML tags
        input_str = re.sub(r'<[^>]*>', '', input_str)
    
    # Remove dangerous characters that could be used for injection
    dangerous_chars = {
        '<': '', '>': '', '"': '', "'": '', '`': '', '\\': '',
        ';': '', '(': '', ')': '', '{': '', '}': '', '[': '', ']': '',
        '\x00': '', '\x0a': '', '\x0d': '', '\x1a': ''
    }
    
    for char, replacement in dangerous_chars.items():
        input_str = input_str.replace(char, replacement)
    
    # Remove script-related keywords and patterns (case insensitive)
    script_patterns = [
        r'javascript\s*:', r'vbscript\s*:', r'data\s*:', r'file\s*:', r'ftp\s*:',
        r'on\w+\s*=', r'<script', r'</script>', r'<iframe', r'</iframe>',
        r'<object', r'</object>', r'<embed', r'</embed>',
        r'expression\s*\(', r'url\s*\(', r'import\s+', r'@import',
        r'eval\s*\(', r'setTimeout\s*\(', r'setInterval\s*\(',
        r'document\s*\.', r'window\s*\.', r'alert\s*\(', r'confirm\s*\('
    ]
    
    for pattern in script_patterns:
        input_str = re.sub(pattern, '', input_str, flags=re.IGNORECASE)
    
    # Remove SQL injection patterns
    sql_patterns = [
        r'union\s+select', r'union\s+all\s+select', r'drop\s+table', r'delete\s+from',
        r'insert\s+into', r'update\s+set', r'exec\s*\(', r'execute\s*\(',
        r'--\s*', r'/\*.*?\*/', r'xp_cmdshell', r'sp_executesql'
    ]
    
    for pattern in sql_patterns:
        input_str = re.sub(pattern, '', input_str, flags=re.IGNORECASE)
    
    # Normalize whitespace and trim
    input_str = re.sub(r'\s+', ' ', input_str).strip()
    
    return input_str

def validate_search_query(query: str) -> Tuple[bool, str, str]:
    """
    Validate search query with comprehensive security checks
    Returns: (is_valid, cleaned_query, error_message)
    """
    if not query:
        return True, "", ""
    
    original_query = query
    
    # Length validation
    if len(query) > 200:
        security_logger.warning(f"Query too long: {len(query)} chars - {query[:50]}...")
        return False, "", "Search query too long (max 200 characters)"
    
    # Check for suspicious patterns that might indicate attacks
    suspicious_patterns = [
        (r'union\s+select', "SQL injection attempt"),
        (r'drop\s+table', "SQL injection attempt"),
        (r'delete\s+from', "SQL injection attempt"),
        (r'insert\s+into', "SQL injection attempt"),
        (r'update\s+set', "SQL injection attempt"),
        (r'exec\s*\(', "Code execution attempt"),
        (r'<script', "XSS attempt"),
        (r'javascript:', "XSS attempt"),
        (r'vbscript:', "XSS attempt"),
        (r'data:text/html', "XSS attempt"),
        (r'expression\s*\(', "CSS injection attempt"),
        (r'@import', "CSS injection attempt"),
        (r'document\.cookie', "XSS attempt"),
        (r'document\.write', "XSS attempt"),
        (r'eval\s*\(', "Code injection attempt"),
        (r'setTimeout\s*\(', "Code injection attempt"),
        (r'setInterval\s*\(', "Code injection attempt")
    ]
    
    for pattern, attack_type in suspicious_patterns:
        if re.search(pattern, query, re.IGNORECASE):
            security_logger.warning(f"{attack_type} detected in query: {query}")
            return False, "", "Invalid characters in search query"
    
    # Sanitize the query
    cleaned_query = sanitize_input(query, max_length=200)
    
    # Check if sanitization removed too much (might indicate malicious input)
    if len(cleaned_query) < len(original_query) * 0.5 and len(original_query) > 10:
        security_logger.warning(f"Heavy sanitization required for query: {original_query}")
        # Still allow it but log the event
    
    return True, cleaned_query, ""

def validate_filter_values(values: List[str], allowed_values: Optional[List[str]] = None, 
                          max_items: int = 50, min_length: int = 1) -> List[str]:
    """
    Validate and sanitize filter values (countries, organizations, sources)
    """
    if not values:
        return []
    
    # Limit number of filter values to prevent DoS
    if len(values) > max_items:
        security_logger.warning(f"Too many filter values: {len(values)}, limiting to {max_items}")
        values = values[:max_items]
    
    sanitized = []
    for value in values:
        if not isinstance(value, str):
            continue
            
        clean_value = sanitize_input(value, max_length=100)
        
        # Skip empty or too short values
        if not clean_value or len(clean_value) < min_length:
            continue
            
        # Check against allowed values if provided
        if allowed_values is not None and clean_value not in allowed_values:
            security_logger.warning(f"Invalid filter value: {clean_value}")
            continue
            
        sanitized.append(clean_value)
    
    return sanitized

def validate_integer_param(value: str, min_val: int = 0, max_val: int = 10000, 
                          default: int = 0) -> int:
    """
    Safely validate and convert integer parameters
    """
    try:
        int_val = int(value)
        if int_val < min_val or int_val > max_val:
            security_logger.warning(f"Integer parameter out of range: {int_val}")
            return default
        return int_val
    except (ValueError, TypeError):
        return default

def check_rate_limit(identifier: str, max_requests: int = 30, 
                    window_seconds: int = 60) -> Tuple[bool, int]:
    """
    Simple rate limiting check
    Returns: (is_allowed, remaining_requests)
    In production, use Redis for distributed rate limiting
    """
    current_time = time.time()
    
    # Clean old entries
    if identifier in _rate_limit_storage:
        _rate_limit_storage[identifier] = [
            timestamp for timestamp in _rate_limit_storage[identifier]
            if current_time - timestamp < window_seconds
        ]
    else:
        _rate_limit_storage[identifier] = []
    
    # Check if limit exceeded
    if len(_rate_limit_storage[identifier]) >= max_requests:
        return False, 0
    
    # Add current request
    _rate_limit_storage[identifier].append(current_time)
    
    remaining = max_requests - len(_rate_limit_storage[identifier])
    return True, remaining

def log_security_event(event_type: str, details: str, ip_address: str = None, 
                      user_agent: str = None, endpoint: str = None):
    """
    Log security-related events
    """
    event_data = {
        'event_type': event_type,
        'details': details,
        'timestamp': datetime.utcnow().isoformat(),
        'ip_address': ip_address,
        'user_agent': user_agent,
        'endpoint': endpoint
    }
    
    security_logger.warning(f"SECURITY EVENT: {event_data}")

def escape_for_fulltext_search(query: str) -> str:
    """
    Escape special characters for full-text search engines
    """
    if not query:
        return ""
    
    # MySQL/PostgreSQL full-text search special characters
    special_chars = ['+', '-', '>', '<', '(', ')', '~', '*', '"', '@', '!']
    
    for char in special_chars:
        query = query.replace(char, f'\\{char}')
    
    return query

def get_