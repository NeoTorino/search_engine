# Complete Security Hardening Guide for Job Search Website

## Current Security Analysis

Your application already has some good security measures:
- HTTPS enforcement with SSL/TLS configuration
- CSP nonce implementation
- Basic input sanitization with `sanitize_input()`
- Secure headers middleware
- ProxyFix for proper header handling

## 1. Enhanced Input Sanitization & Validation

### Backend Improvements (Python/Flask)

#### Enhanced sanitize_input function
```python
import re
import html
from urllib.parse import quote
import bleach

def sanitize_input(input_str, max_length=200, allow_basic_html=False):
    """
    Comprehensive input sanitization
    """
    if not input_str or not isinstance(input_str, str):
        return ""
    
    # Remove null bytes and control characters
    input_str = input_str.replace('\x00', '')
    input_str = ''.join(char for char in input_str if ord(char) >= 32 or char in '\t\n\r')
    
    # Normalize unicode
    import unicodedata
    input_str = unicodedata.normalize('NFKC', input_str)
    
    # Length limiting
    input_str = input_str[:max_length]
    
    if allow_basic_html:
        # Use bleach for HTML sanitization
        allowed_tags = ['b', 'i', 'em', 'strong']
        input_str = bleach.clean(input_str, tags=allowed_tags, strip=True)
    else:
        # Remove all HTML/XML tags
        input_str = re.sub(r'<[^>]*>', '', input_str)
    
    # Remove dangerous characters for SQL/NoSQL injection
    dangerous_chars = ['<', '>', '"', "'", '`', '\\', ';', '(', ')', '{', '}', '[', ']']
    for char in dangerous_chars:
        input_str = input_str.replace(char, '')
    
    # Remove script-related keywords (case insensitive)
    script_patterns = [
        r'javascript:', r'vbscript:', r'data:', r'file:', r'ftp:',
        r'on\w+\s*=', r'script', r'iframe', r'object', r'embed',
        r'expression\s*\(', r'url\s*\(', r'import\s+', r'@import'
    ]
    
    for pattern in script_patterns:
        input_str = re.sub(pattern, '', input_str, flags=re.IGNORECASE)
    
    # Trim whitespace
    input_str = input_str.strip()
    
    return input_str

def validate_search_query(query):
    """
    Validate search query with additional checks
    """
    if not query:
        return True, ""
    
    # Check for excessively long queries
    if len(query) > 200:
        return False, "Search query too long"
    
    # Check for suspicious patterns
    suspicious_patterns = [
        r'union\s+select', r'drop\s+table', r'delete\s+from',
        r'insert\s+into', r'update\s+set', r'exec\s*\(',
        r'<script', r'javascript:', r'vbscript:'
    ]
    
    for pattern in suspicious_patterns:
        if re.search(pattern, query, re.IGNORECASE):
            return False, "Invalid characters in search query"
    
    return True, sanitize_input(query)

def validate_filter_values(values, allowed_values=None, max_items=50):
    """
    Validate filter values (countries, organizations, sources)
    """
    if not values:
        return []
    
    if len(values) > max_items:
        values = values[:max_items]
    
    sanitized = []
    for value in values:
        clean_value = sanitize_input(value, max_length=100)
        if clean_value and len(clean_value) >= 2:  # Minimum length check
            if allowed_values is None or clean_value in allowed_values:
                sanitized.append(clean_value)
    
    return sanitized
```

#### Rate Limiting Implementation
```python
from flask_limiter import Limiter
from flask_limiter.util import get_remote_address
import redis

# Add to app.py
limiter = Limiter(
    app,
    key_func=get_remote_address,
    storage_uri="redis://localhost:6379",  # Configure your Redis
    default_limits=["1000 per day", "100 per hour"]
)

# Add to routes
@main.route("/search")
@limiter.limit("30 per minute")  # Aggressive rate limiting for search
def search_results():
    # ... existing code

@main.route("/api/stats/word-cloud")
@limiter.limit("10 per minute")  # Even more restrictive for compute-heavy operations
def stats_word_cloud():
    # ... existing code
```

### Frontend Improvements (JavaScript)

#### Enhanced sanitizeInput function
```javascript
function sanitizeInput(input, maxLength = 200, allowSpecialChars = false) {
    if (!input || typeof input !== 'string') {
        return '';
    }
    
    // Remove null bytes and control characters
    input = input.replace(/\x00/g, '');
    input = input.replace(/[\x00-\x1F\x7F-\x9F]/g, '');
    
    // Length limiting
    input = input.substring(0, maxLength);
    
    // Remove HTML tags
    input = input.replace(/<[^>]*>/g, '');
    
    // Remove dangerous characters
    if (!allowSpecialChars) {
        input = input.replace(/[<>"'`\\;(){}[\]]/g, '');
    }
    
    // Remove script-related content
    const scriptPatterns = [
        /javascript:/gi,
        /vbscript:/gi,
        /data:/gi,
        /on\w+\s*=/gi,
        /script/gi,
        /iframe/gi,
        /object/gi,
        /embed/gi
    ];
    
    scriptPatterns.forEach(pattern => {
        input = input.replace(pattern, '');
    });
    
    // Normalize whitespace
    input = input.replace(/\s+/g, ' ').trim();
    
    return input;
}

function validateSearchInput(input) {
    const cleaned = sanitizeInput(input);
    
    // Additional validation
    if (cleaned.length > 200) {
        return { valid: false, message: "Search query too long", value: "" };
    }
    
    if (cleaned.length < 1) {
        return { valid: true, message: "", value: cleaned };
    }
    
    // Check for suspicious patterns
    const suspiciousPatterns = [
        /union\s+select/i,
        /drop\s+table/i,
        /delete\s+from/i,
        /insert\s+into/i,
        /exec\s*\(/i
    ];
    
    for (const pattern of suspiciousPatterns) {
        if (pattern.test(cleaned)) {
            return { valid: false, message: "Invalid search query", value: "" };
        }
    }
    
    return { valid: true, message: "", value: cleaned };
}
```

## 2. Enhanced Security Headers

#### Updated secure_headers.py
```python
from flask import g, request
import secrets

def apply_secure_headers(response):
    """Apply comprehensive security headers"""
    
    # Get CSP nonce
    nonce = getattr(g, 'csp_nonce', secrets.token_urlsafe(16))
    
    # Content Security Policy (very strict)
    csp_policy = (
        f"default-src 'self'; "
        f"script-src 'self' 'nonce-{nonce}' https://cdnjs.cloudflare.com; "
        f"style-src 'self' 'unsafe-inline' https://cdnjs.cloudflare.com; "
        f"img-src 'self' data: https:; "
        f"font-src 'self' https://cdnjs.cloudflare.com; "
        f"connect-src 'self'; "
        f"frame-src 'none'; "
        f"object-src 'none'; "
        f"base-uri 'self'; "
        f"form-action 'self'; "
        f"frame-ancestors 'none'; "
        f"upgrade-insecure-requests"
    )
    
    response.headers['Content-Security-Policy'] = csp_policy
    
    # Security headers
    response.headers['X-Content-Type-Options'] = 'nosniff'
    response.headers['X-Frame-Options'] = 'DENY'
    response.headers['X-XSS-Protection'] = '1; mode=block'
    response.headers['Referrer-Policy'] = 'strict-origin-when-cross-origin'
    
    # HSTS (if HTTPS)
    if request.is_secure:
        response.headers['Strict-Transport-Security'] = 'max-age=31536000; includeSubDomains; preload'
    
    # Additional security headers
    response.headers['X-Permitted-Cross-Domain-Policies'] = 'none'
    response.headers['Cross-Origin-Embedder-Policy'] = 'require-corp'
    response.headers['Cross-Origin-Opener-Policy'] = 'same-origin'
    response.headers['Cross-Origin-Resource-Policy'] = 'same-origin'
    
    # Remove server information
    response.headers.pop('Server', None)
    response.headers.pop('X-Powered-By', None)
    
    # Cache control for sensitive pages
    if request.endpoint in ['search_results', 'stats']:
        response.headers['Cache-Control'] = 'no-store, no-cache, must-revalidate, private'
        response.headers['Pragma'] = 'no-cache'
        response.headers['Expires'] = '0'
    
    return response
```

## 3. Database Security (if applicable)

```python
# Use parameterized queries ALWAYS
def safe_query_example(query, params):
    """Example of safe database querying"""
    # Never do: f"SELECT * FROM jobs WHERE title LIKE '%{query}%'"
    # Always do:
    cursor.execute("SELECT * FROM jobs WHERE title LIKE %s", (f"%{query}%",))
    
def escape_for_fulltext_search(query):
    """Escape special characters for full-text search"""
    # MySQL/PostgreSQL full-text search escaping
    special_chars = ['+', '-', '>', '<', '(', ')', '~', '*', '"', '@']
    for char in special_chars:
        query = query.replace(char, f'\\{char}')
    return query
```

## 4. Enhanced Error Handling

```python
import logging
from flask import request
import traceback

# Configure logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s %(levelname)s [%(name)s] %(message)s',
    handlers=[
        logging.FileHandler('security.log'),
        logging.StreamHandler()
    ]
)

security_logger = logging.getLogger('security')

def log_security_event(event_type, details, request_info=None):
    """Log security-related events"""
    if request_info is None:
        request_info = {
            'ip': request.remote_addr,
            'user_agent': request.headers.get('User-Agent', ''),
            'endpoint': request.endpoint,
            'method': request.method
        }
    
    security_logger.warning(f"SECURITY EVENT: {event_type} - {details} - {request_info}")

# Updated error handlers
@main.app_errorhandler(400)
def bad_request(error):
    log_security_event("BAD_REQUEST", str(error))
    return render_template('errors/400.html'), 400

@main.app_errorhandler(429)
def rate_limit_exceeded(error):
    log_security_event("RATE_LIMIT_EXCEEDED", str(error))
    return render_template('errors/429.html'), 429

@main.app_errorhandler(500)
def internal_server_error(error):
    # Log error but don't expose internal details
    security_logger.error(f"Internal error: {traceback.format_exc()}")
    return render_template('errors/500.html'), 500
```

## 5. Input Validation Middleware

```python
from functools import wraps
from flask import request, jsonify, abort

def validate_request_size(max_size=1024*1024):  # 1MB default
    """Validate request size to prevent DoS"""
    def decorator(f):
        @wraps(f)
        def decorated_function(*args, **kwargs):
            if request.content_length and request.content_length > max_size:
                log_security_event("LARGE_REQUEST", f"Size: {request.content_length}")
                abort(413)  # Request Entity Too Large
            return f(*args, **kwargs)
        return decorated_function
    return decorator

def validate_json_request(f):
    """Validate JSON requests"""
    @wraps(f)
    def decorated_function(*args, **kwargs):
        if request.is_json:
            try:
                # Limit JSON depth and size
                data = request.get_json(force=True)
                if isinstance(data, dict) and len(str(data)) > 10000:
                    log_security_event("LARGE_JSON", "JSON too large")
                    abort(400)
            except Exception as e:
                log_security_event("INVALID_JSON", str(e))
                abort(400)
        return f(*args, **kwargs)
    return decorated_function
```

## 6. Updated Route Security

```python
# Apply security decorators to routes
@main.route("/search")
@validate_request_size(max_size=2048)  # Small limit for search
@limiter.limit("30 per minute")
def search_results():
    # Enhanced input validation
    raw_query = request.args.get("q", "")
    
    # Validate query
    is_valid, clean_query = validate_search_query(raw_query)
    if not is_valid:
        log_security_event("INVALID_SEARCH_QUERY", f"Query: {raw_query}")
        abort(400)
    
    # Validate filters
    selected_countries = validate_filter_values(
        [sanitize_input(c) for c in request.args.getlist('country')],
        max_items=10
    )
    
    selected_organizations = validate_filter_values(
        [sanitize_input(o) for o in request.args.getlist('organization')],
        max_items=10
    )
    
    selected_sources = validate_filter_values(
        [sanitize_input(s) for s in request.args.getlist('source')],
        max_items=5
    )
    
    # Validate date range
    try:
        days = int(request.args.get('date_posted_days', 30))
        if days < 0 or days > 365:  # Reasonable limits
            days = 30
    except (ValueError, TypeError):
        days = 30
    
    # Validate offset
    try:
        offset = int(request.args.get('from', 0))
        if offset < 0 or offset > 10000:  # Prevent excessive pagination
            offset = 0
    except (ValueError, TypeError):
        offset = 0
    
    # Continue with existing logic...
```

## 7. Frontend Security Enhancements

#### CSRF Protection
```javascript
// Add CSRF token to all AJAX requests
function getCSRFToken() {
    return document.querySelector('meta[name="csrf-token"]')?.getAttribute('content');
}

function fetchWithSecurity(url, options = {}) {
    options.headers = options.headers || {};
    options.headers['X-Requested-With'] = 'XMLHttpRequest';
    
    const csrfToken = getCSRFToken();
    if (csrfToken) {
        options.headers['X-CSRF-Token'] = csrfToken;
    }
    
    return fetch(url, options);
}
```

#### Input Event Sanitization
```javascript
// Sanitize all input events
document.addEventListener('DOMContentLoaded', function() {
    // Apply to all text inputs
    const textInputs = document.querySelectorAll('input[type="text"], input[type="search"], textarea');
    
    textInputs.forEach(input => {
        input.addEventListener('input', function(e) {
            const validation = validateSearchInput(this.value);
            
            if (!validation.valid) {
                this.setCustomValidity(validation.message);
                this.classList.add('is-invalid');
            } else {
                this.setCustomValidity('');
                this.classList.remove('is-invalid');
                this.value = validation.value;
            }
        });
        
        // Prevent paste of dangerous content
        input.addEventListener('paste', function(e) {
            setTimeout(() => {
                const validation = validateSearchInput(this.value);
                if (!validation.valid) {
                    this.value = validation.value;
                    this.setCustomValidity(validation.message);
                }
            }, 0);
        });
    });
});
```

## 8. Environment & Configuration Security

#### Enhanced app.py configuration
```python
import os
from datetime import timedelta

# Security configuration
app.config.update(
    SECRET_KEY=os.environ.get('SECRET_KEY', secrets.token_hex(32)),
    PERMANENT_SESSION_LIFETIME=timedelta(hours=1),
    SESSION_COOKIE_SECURE=True,
    SESSION_COOKIE_HTTPONLY=True,
    SESSION_COOKIE_SAMESITE='Lax',
    WTF_CSRF_TIME_LIMIT=3600,
    MAX_CONTENT_LENGTH=1024*1024,  # 1MB max request size
)

# Disable debug in production
if os.environ.get('FLASK_ENV') == 'production':
    app.config['DEBUG'] = False
    app.config['TESTING'] = False
```

## 9. Monitoring & Alerting

```python
def setup_security_monitoring():
    """Setup security event monitoring"""
    
    # Failed request attempts
    failed_requests = {}
    
    @app.before_request
    def monitor_requests():
        ip = request.remote_addr
        endpoint = request.endpoint
        
        # Track suspicious patterns
        if any(pattern in request.url.lower() for pattern in 
               ['union+select', 'drop+table', '<script', 'javascript:']):
            log_security_event("SUSPICIOUS_REQUEST", f"URL: {request.url}")
            
        # Track high-frequency requests
        current_time = time.time()
        if ip not in failed_requests:
            failed_requests[ip] = []
        
        # Clean old entries
        failed_requests[ip] = [t for t in failed_requests[ip] if current_time - t < 300]  # 5 minutes
        
        if len(failed_requests[ip]) > 20:  # More than 20 requests in 5 minutes
            log_security_event("HIGH_FREQUENCY_REQUESTS", f"IP: {ip}")
```

## 10. Deployment Security Checklist

### Server Configuration
- [ ] Use a reverse proxy (nginx/Apache) with security headers
- [ ] Enable fail2ban for intrusion prevention
- [ ] Configure firewall (ufw/iptables) to only allow necessary ports
- [ ] Regular security updates for OS and dependencies
- [ ] Use non-root user for application
- [ ] Disable unnecessary services
- [ ] Configure log rotation and monitoring

### SSL/TLS Configuration
- [ ] Use strong cipher suites
- [ ] Enable HSTS preloading
- [ ] Use certificate pinning if possible
- [ ] Regular certificate renewal automation

### Monitoring
- [ ] Set up log aggregation (ELK stack, Splunk, etc.)
- [ ] Monitor for security events
- [ ] Set up alerts for suspicious activities
- [ ] Regular security audits

This comprehensive security implementation will significantly harden your job search website against common web vulnerabilities and attacks.